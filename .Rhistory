galaxy_data_table = data.table::data.table("particle_ID" = seq(1, length(galaxy_data$x)), "spaxel_ID"=galaxy_data$pixel_pos)
observation$sbin_size
currentBin = which(count == max(count))
x = part_in_spaxel$spaxel_ID %% observation$sbin
y = part_in_spaxel$spaxel_ID %/% observation$sbin
count = sapply(X = part_in_spaxel$val, FUN = length)
target_count = observation$particle_limit # minimum number of particles per pixel
pixel_size = observation$sbin_size # kpc per pixel
part_in_spaxel = galaxy_data_table[, list(val=list(particle_ID)), by = "spaxel_ID"]
x = part_in_spaxel$spaxel_ID %% observation$sbin
y = part_in_spaxel$spaxel_ID %/% observation$sbin
count = sapply(X = part_in_spaxel$val, FUN = length)
target_count = observation$particle_limit # minimum number of particles per pixel
pixel_size = observation$sbin_size # kpc per pixel
currentBin = which(count == max(count))
classe = integer(length=n)
n = length(x)
classe = integer(length=n)
good = numeric(length=n)
(all(classe) != 0)
unBinned = which(classe == 0)
ind = 1
currentBin = which(count == max(count)) # start from the bin with the max number of pixels
classe[currentBin] = ind # Here, the current bin is one pixel
xBar = x[currentBin]; yBar = y[currentBin] # centroid of the one pixel
if (all(classe) != 0){
stop()
} # stop if all pixels are binned
(all(classe != 0))
unBinned = which(classe == 0)
k = (x[unBinned] - xBar)^2 + (y[unBinned] - yBar)^2
# (1) Find the distance to the closest pixel to the current bin
minDist = min((x[currentBin] - x[unBinned[k]])^2 + (y[currentBin] - y[unBinned[k]])^2)
k = min((x[unBinned] - xBar)^2 + (y[unBinned] - yBar)^2) # how far away are unbinned pixels from currentBin?
unBinned = which(classe == 0) # which pixels are unbinned?
(x[unBinned] - xBar)^2 + (y[unBinned] - yBar)^2
k_vals = (x[unBinned] - xBar)^2 + (y[unBinned] - yBar)^2 # how far away are unbinned pixels from currentBin?
k = which(k_vals = min(k_vals))
k = which(k_vals == min(k_vals))
# (1) Find the distance to the closest pixel to the current bin
minDist = min((x[currentBin] - x[unBinned[k]])^2 + (y[currentBin] - y[unBinned[k]])^2)
k_vals = argmin(x[unBinned] - xBar)^2 + (y[unBinned] - yBar)^2 # how far away are unbinned pixels from currentBin?
k_vals = which.min((x[unBinned] - xBar)^2 + (y[unBinned] - yBar)^2) # how far away are unbinned pixels from currentBin?
k = which(k_vals == min(k_vals))
# (1) Find the distance to the closest pixel to the current bin
minDist = min((x[currentBin] - x[unBinned[k]])^2 + (y[currentBin] - y[unBinned[k]])^2)
k_vals = (x[unBinned] - xBar)^2 + (y[unBinned] - yBar)^2 # how far away are unbinned pixels from currentBin?
k = which(k_vals == min(k_vals))
# (1) Find the distance to the closest pixel to the current bin
minDist = min((x[currentBin] - x[unBinned[k]])^2 + (y[currentBin] - y[unBinned[k]])^2)
# (1) Find the distance to the closest pixel to the current bin
minDist = (x[currentBin] - x[unBinned[k]])^2 + (y[currentBin] - y[unBinned[k]])^2
# (2) Estimate the roundness of the possible new bin
nextBin = c(currentBin, unBinned[k])
k_vals = which.min((x[unBinned] - xBar)^2 + (y[unBinned] - yBar)^2) # how far away are unbinned pixels from currentBin?
# (1) Find the distance to the closest pixel to the current bin
minDist = (x[currentBin] - x[unBinned[k]])^2 + (y[currentBin] - y[unBinned[k]])^2
unBinned = which(classe == 0) # which pixels are unbinned?
k = which.min((x[unBinned] - xBar)^2 + (y[unBinned] - yBar)^2) # how far away are unbinned pixels from currentBin?
# (1) Find the distance to the closest pixel to the current bin
minDist = (x[currentBin] - x[unBinned[k]])^2 + (y[currentBin] - y[unBinned[k]])^2
# (2) Estimate the roundness of the possible new bin
nextBin = c(currentBin, unBinned[k])
.roundness = function(x, y, pixel_size){
n = length(x)
equivalentRadius = sqrt(n/pi)*pixel_size
xBar = mean(x); yBar = mean(y)
maxDistance = sqrt(max((x-xBar)^2 + (y-yBar)^2))
roundness = (maxDistance/equivalentRadius) - 1
return(roundness)
}
roundness = .roundness(x[nextBin], y[nextBin], pixel_size)
count[currentBin]
newCount = sum(count[nextBin])
sqrt(minDist) > 1.2*pixel_size
oldCount > 0.8*target_count
# (3) Compute the count obtained by adding the candidate pixel
oldCount = count[currentBin]
newCount = sum(count[nextBin])
sqrt(minDist) > 1.2*pixel_size | roundness > 0.3 |
abs(newCount - target_count) > abs(oldCount - target_count) | oldCount > newCount
oldCount > 0.8*target_count
# if all three criteria are negative, accept the new pixel and add to the current bin
classe[unBinned[k]] = ind
binned = classe[classe > 0]
classe[currentBin] = ind # Here, the current bin is one pixel
xBar = x[currentBin]; yBar = y[currentBin] # centroid of the one pixel
n = length(x)
classe = integer(length=n)
good = numeric(length=n)
currentBin = which(count == max(count)) # start from the bin with the max number of pixels
classe[currentBin] = ind # Here, the current bin is one pixel
xBar = x[currentBin]; yBar = y[currentBin] # centroid of the one pixel
cond = T
while (cond){
if (all(classe != 0)){
cond = F
} # stop if all pixels are binned
unBinned = which(classe == 0) # which pixels are unbinned?
k = which.min((x[unBinned] - xBar)^2 + (y[unBinned] - yBar)^2) # how far away are unbinned pixels from currentBin?
# (1) Find the distance to the closest pixel to the current bin
minDist = (x[currentBin] - x[unBinned[k]])^2 + (y[currentBin] - y[unBinned[k]])^2
# (2) Estimate the roundness of the possible new bin
nextBin = c(currentBin, unBinned[k])
roundness = .roundness(x[nextBin], y[nextBin], pixel_size)
# (3) Compute the count obtained by adding the candidate pixel
oldCount = count[currentBin]
newCount = sum(count[nextBin])
if (sqrt(minDist) > 1.2*pixel_size | roundness > 0.3 |
abs(newCount - target_count) > abs(oldCount - target_count) | oldCount > newCount){
if (oldCount > 0.8*target_count){
good[currentBin] = 1
}
cond = F
}
# if current pixel already meets bin criteria, no need to add a pixel
# if all three criteria are negative, accept the new pixel and add to the current bin
classe[unBinned[k]] = ind
currentBin = nextBin
# update the centroid of the current bin
xBar = mean(x[currentBin]); yBar = mean(y[currentBin])
}
binned = classe[classe > 0]
n = length(x)
classe = integer(length=n)
good = numeric(length=n)
currentBin = which(count == max(count)) # start from the bin with the max number of pixels
classe[currentBin] = ind # Here, the current bin is one pixel
xBar = x[currentBin]; yBar = y[currentBin] # centroid of the one pixel
cond = T
while (cond){
if (all(classe != 0)){
break
} # stop if all pixels are binned
unBinned = which(classe == 0) # which pixels are unbinned?
k = which.min((x[unBinned] - xBar)^2 + (y[unBinned] - yBar)^2) # how far away are unbinned pixels from currentBin?
# (1) Find the distance to the closest pixel to the current bin
minDist = (x[currentBin] - x[unBinned[k]])^2 + (y[currentBin] - y[unBinned[k]])^2
# (2) Estimate the roundness of the possible new bin
nextBin = c(currentBin, unBinned[k])
roundness = .roundness(x[nextBin], y[nextBin], pixel_size)
# (3) Compute the count obtained by adding the candidate pixel
oldCount = count[currentBin]
newCount = sum(count[nextBin])
if (sqrt(minDist) > 1.2*pixel_size | roundness > 0.3 |
abs(newCount - target_count) > abs(oldCount - target_count) | oldCount > newCount){
if (oldCount > 0.8*target_count){
good[currentBin] = 1
}
break
}
# if current pixel already meets bin criteria, no need to add a pixel
# if all three criteria are negative, accept the new pixel and add to the current bin
classe[unBinned[k]] = ind
currentBin = nextBin
# update the centroid of the current bin
xBar = mean(x[currentBin]); yBar = mean(y[currentBin])
}
binned = classe[classe > 0]
binned = classe > 0
xBar = mean(x[binned]); yBar = mean(y[binned])
# Find the next closest unbinned pixel to the centroid of all binned pixels
unBinned = which(classe == 0)
.roundness = function(x, y, pixel_size){
n = length(x)
equivalentRadius = sqrt(n/pi)*pixel_size
xBar = mean(x); yBar = mean(y)
maxDistance = sqrt(max((x-xBar)^2 + (y-yBar)^2))
roundness = (maxDistance/equivalentRadius) - 1
return(roundness)
}
.accretion = function(x, y, count, target_count, pixel_size){
n = length(x)
classe = integer(length=n)
good = numeric(length=n)
currentBin = which(count == max(count)) # start from the bin with the max number of pixels
for (ind in 1:(n+1)){
classe[currentBin] = ind # Here, the current bin is one pixel
xBar = x[currentBin]; yBar = y[currentBin] # centroid of the one pixel
cond = T
while (cond){
if (all(classe != 0)){
break
} # stop if all pixels are binned
unBinned = which(classe == 0) # which pixels are unbinned?
k = which.min((x[unBinned] - xBar)^2 + (y[unBinned] - yBar)^2) # how far away are unbinned pixels from currentBin?
# (1) Find the distance to the closest pixel to the current bin
minDist = (x[currentBin] - x[unBinned[k]])^2 + (y[currentBin] - y[unBinned[k]])^2
# (2) Estimate the roundness of the possible new bin
nextBin = c(currentBin, unBinned[k])
roundness = .roundness(x[nextBin], y[nextBin], pixel_size)
# (3) Compute the count obtained by adding the candidate pixel
oldCount = count[currentBin]
newCount = sum(count[nextBin])
if (sqrt(minDist) > 1.2*pixel_size | roundness > 0.3 |
abs(newCount - target_count) > abs(oldCount - target_count) | oldCount > newCount){
if (oldCount > 0.8*target_count){
good[currentBin] = 1
}
break
}
# if current pixel already meets bin criteria, no need to add a pixel
# if all three criteria are negative, accept the new pixel and add to the current bin
classe[unBinned[k]] = ind
currentBin = nextBin
# update the centroid of the current bin
xBar = mean(x[currentBin]); yBar = mean(y[currentBin])
}
binned = classe > 0
if (all(binned)){
break
} #stop if all pixels have been binned
xBar = mean(x[binned]); yBar = mean(y[binned])
# Find the next closest unbinned pixel to the centroid of all binned pixels
unBinned = which(classe == 0)
if (sum(count[unBinned]) < target_count){
break
} # if the remaining pixels do not have enough capacity left, stop
k = which.min((x[unBinned] - xBar)^2 + (y[unBinned] - yBar)^2)
currentBin = unBinned[k]
}
classe = classe*good # set to zero bins that did not reach target counts
return(classe)
}
x = part_in_spaxel$spaxel_ID %% observation$sbin
y = part_in_spaxel$spaxel_ID %/% observation$sbin
count = sapply(X = part_in_spaxel$val, FUN = length)
target_count = observation$particle_limit # minimum number of particles per pixel
pixel_size = observation$sbin_size # kpc per pixel
classe = .accretion(x, y, count, target_count, pixel_size)
View(classe)
all(classe == 0)
which(classe != 0)
classe[which(classe != 0)]
length(classe[which(classe != 0)])
# Find the centroid of all successful bins
good = unique(classe[classe>0])
simulation_data = system.file("extdata", "SimSpin_example_Gadget",
package = "SimSpin")
simspin_data    = make_simspin_file(filename = simulation_data,
disk_age = 5, # ages are assigned in Gyr
bulge_age = 10,
disk_Z = 0.024, # metallicities are wrt solar
bulge_Z = 0.001,
template = "BC03lr", # SSP template used
write_to_file = FALSE)
library(simspin)
library(SimSpin)
simulation_data = system.file("extdata", "SimSpin_example_Gadget",
package = "SimSpin")
simspin_data    = make_simspin_file(filename = simulation_data,
disk_age = 5, # ages are assigned in Gyr
bulge_age = 10,
disk_Z = 0.024, # metallicities are wrt solar
bulge_Z = 0.001,
template = "BC03lr", # SSP template used
write_to_file = FALSE)
simulation_data
ifu = telescope(type = "IFU", # other options include pre-defined instruments
method = "spectral", # to generate spectral data cube
fov = 15, # field-of-view in arcsec
aperture_shape = "circular", # shape of fov
wave_range = c(3700,5700), # given in angstroms
wave_centre = 4700, # central wavelength given in angstroms
wave_res = 1.04, # wavelength resolution in angstroms
spatial_res = 0.5, # size of spatial pixels in arcsec
filter = "r", # filter for calc of particle luminosity
lsf_fwhm = 2.65, # full-width half-max of line-spread-function
signal_to_noise = 10) # s/n ratio per angstrom
strategy = observing_strategy(z = 0.1, # redshift distance the galaxy is placed
inc_deg = 70, # projection (0 - face-on, 90 - edge-on)
twist_deg = 0, # angle of observation (longitude)
blur = F, # whether seeing conditions are included
fwhm = 2, # the fwhm of the blurring kernel in arcsec
psf = "Gaussian") # the shape of the blurring kernel
gadget_cube = build_datacube(simspin_file       = simspin_data,
telescope          = ifu,
observing_strategy = strategy,
write_fits         = F)
write_simspin_FITS(simspin_datacube   = gadget_cube,        # build_datacube() output
output_file        = "~/Desktop/gadget_cube.FITS", # filename of output file
input_simspin_file = simulation_data,    # filename of input sim
object_name        = "GalaxyID_unknown", # name of observed object
telescope_name     = "SimSpin",          # name of telescope
instrument_name    = "IFU",              # name of instrument
observer_name      = "Anonymous")        # name of the observer
library(Rfits)
fits_data = Rfits_read_all(filename = 'temp.fits', pointer = FALSE, header = TRUE,
data.table = TRUE)
fits_data = Rfits_read_all(filename = '~/Desktop/gadget_cube.FITS', pointer = FALSE, header = TRUE,
data.table = TRUE)
Rfits_info("~/Desktop/gadget_cube.FITS")
test = Rfits_info("~/Desktop/gadget_cube.FITS")
test
Rfits_read_header(filename = "~/Desktop/gadget_cube.FITS")
source('~/repos/SimSpin/R/write_simspin_FITS.R', echo=TRUE)
library(Rfits)
Rfits_read_header("~/Desktop/gadget_cube.FITS")
head = Rfits_read_header("~/Desktop/gadget_cube.FITS")
head$header
library(SimSpin)
sessionInfo()
library(Rfits)
head = Rfits_read_header("~/Desktop/gadget_cube.FITS")
head$header
fits_summary = Rfits_info("~/Desktop/gadget_cube.FITS")
fits_summary$summary
datacube = Rfits_read_image("~/Desktop/gadget_cube.FITS")
datacube = Rfits_read_image("~/Desktop/gadget_cube.FITS", ext = 2)
datacube$header
log(0.02)
10^log10(0.02)
0.02e9
20/221
library(SimSpin)
ss_eagle = system.file("extdata", "SimSpin_example_EAGLE.hdf5", package = "SimSpin")
temp_loc = tempdir()
make_simspin_file(ss_eagle, output = paste(temp_loc, "spectra.Rdata", sep=""))
cube = build_datacube(simspin_file = paste(temp_loc, "spectra.Rdata", sep=""),
telescope = telescope(type="SAMI"),
observing_strategy = observing_strategy())
output_file = paste(temp_loc, "cube.fits", sep="")
simspin_datacube = cube
object_name = "SimSpin EAGLE example"
telescope_name = "AAO"
instrument_name = "SAMI"
observer_name = "K.E.Harborne"
input_simspin_file = paste(temp_loc, "spectra.Rdata", sep="")
observation = simspin_datacube$observation
simspin_cube = simspin_datacube[[1]] # getting either the "velocity cube" or the "spectral cube"
# Making header for file and saving to HDU 1 ----
output_name = rev(stringr::str_split(output_file, "/")[[1]])[1]
header_keyvalues = list("SIMPLE"=TRUE, "BITPIX"=8, "NAXIS"=0, "EXTEND"=TRUE,
"DATE"=Sys.time(), "ORIGIN"="SimSpin", "TELESCOP"=telescope_name,
"INSTRUME"=instrument_name, "RA"=0, "DEC"=0, "EQINOX"=2000,
"RADECSYS"="FK5", "EXPTIME"=1320, "MJD-OBS"=58906.11,
"DATE-OBS"=observation$date, "UTC"=9654, "LST"=30295.18,
"PI-COI"="UNKNOWN", "OBSERVER"=observer_name, "REDSHIFT"=observation$z,
"PIPEFILE"=output_name,
"BUNIT"="erg/s/cm**2",
"ARCFILE"=input_simspin_file,
"DATAMD5"="4aece79473a5c88f6533382655e948bf",
"OBJECT"=object_name)
View(header_keyvalues)
data_keyvalues = list("XTENSION" = "IMAGE", "BITPIX"=-32, "NAXIS"=3,
"NAXIS1"=dim(simspin_cube)[1], "NAXIS2"=dim(simspin_cube)[2],
"NAXIS3"=dim(simspin_cube)[3], "PCOUNT"=0, "GCOUNT"=1,
"EXTNAME"="DATA", "HDUCLASS"="ESO",
"HDUDOC"="DICD", "HDUVERS"="DCID version 6",
"HDUCLAS1"="IMAGE", "HDUCLAS2"="DATA", "ERRDATA"="STAT",
"OBJECT"=object_name, "BUNIT"="erg/s/cm**2",
"CRPIX1"=1, "CRPIX2"=1,
"CDELT1"=-observation$sbin_size/observation$ang_size/3600,
"CDELT2"=observation$sbin_size/observation$ang_size/3600,
"CUNIT1"="deg", "CUNIT2"="deg",
"CTYPE1"="RA---TAN", "CTYPE2"="DEC--TAN",
"CSYER1"=character(1), "CSYER2"=character(1),
"CRVAL1"=(diff(observation$sbin_seq[1:2])/2 + observation$sbin_seq[1])/observation$ang_size/3600,
"CRVAL2"=(diff(observation$sbin_seq[1:2])/2 + observation$sbin_seq[1])/observation$ang_size/3600,
"CTYPE3"=character(1), "CUNIT3"=character(1),
"CDELT3"=numeric(1), "CRPIX3"=1,
"CRVAL3"=numeric(1))
data_keycomments = list("XTENSION"="IMAGE extension",
"BITPIX"="number of bits per data pixel",
"NAXIS"="number of data axes",
"NAXIS1"="axis length", "NAXIS2"="axis length",
"NAXIS3"="axis length",
"PCOUNT"="required keyword; must = 0",
"GCOUNT"="required keyword; must = 1",
"EXTNAME"="This extension contains data values",
"HDUCLASS"="class name (ESO format)",
"HDUDOC"="document with class description",
"HDUVERS"="version number (according to spec v2.5.1)",
"HDUCLAS1"="Image data format",
"HDUCLAS2"="this extension contains the data itself",
"ERRDATA"="pointer to the variance extension",
"OBJECT"="simulation and galaxy ID number",
"BUNIT"="Angstrom",
"CRPIX1"="Pixel coordinate of reference point",
"CRPIX2"="Pixel coordinate of reference point",
"CDELT1"="Coordinate transformation matrix element",
"CDELT2"="Coordinate transformation matrix element",
"CUNIT1"="Units of coordinate increment and value",
"CUNIT2"="Units of coordinate increment and value",
"CTYPE1"="Right ascension, gnomonic projection",
"CTYPE2"="Declination, gnomonic projection",
"CSYER1"="[deg] Systematic error in coordinate",
"CSYER2"="[deg] Systematic error in coordinate",
"CRVAL1"="Pixel value at reference point",
"CRVAL2"="Pixel value at reference point",
"CTYPE3"=character(1),
"CUNIT3"="Units of coordinate increment and value",
"CDELT3"="Coordinate transformation matrix element",
"CRPIX3"="Pixel coordinate of reference point",
"CRVAL3"="Pixel value at reference point")
library(SimSpin)
image_keyvalues = list("XTENSION"="IMAGE", "BITPIX"=-64, "NAXIS"=2,
"NAXIS1"=dim(simspin_cube)[1], "NAXIS2"=dim(simspin_cube)[2],
"PCOUNT"=0, "GCOUNT"=1, "BUNIT"=character(1),
"CRPIX1"=1,
"CRVAL1"=(diff(observation$sbin_seq[1:2])/2 + observation$sbin_seq[1])/observation$ang_size/3600,
"CDELT1"=-observation$sbin_size/observation$ang_size/3600,
"CTYPE1"="RA---TAN", "CUNIT1"="deg",
"CRPIX2"=1,
"CRVAL2"=(diff(observation$sbin_seq[1:2])/2 + observation$sbin_seq[1])/observation$ang_size/3600,
"CDELT2"=observation$sbin_size/observation$ang_size/3600,
"CTYPE2"="DEC--TAN", "CUNIT2"="deg", "EXTNAME"=character(1))
image_keycomments = list("XTENSION"="IMAGE extension",
"BITPIX"="number of bits per data pixel",
"NAXIS"="number of data axes",
"NAXIS1"="axis length", "NAXIS2"="axis length",
"PCOUNT"="required keyword; must = 0",
"GCOUNT"="required keyword; must = 1",
"BUNIT"="units of image values",
"CRPIX1"="Pixel coordinate of reference point",
"CRVAL1"="Pixel value at reference point",
"CDELT1"="Coordinate transformation matrix element",
"CTYPE1"="Right ascension, gnomonic projection",
"CUNIT1"="Units of coordinate increment and value",
"CRPIX2"="Pixel coordinate of reference point",
"CRVAL2"="Pixel value at reference point",
"CDELT2"="Coordinate transformation matrix element",
"CTYPE2"="Declination, gnomonic projection",
"CUNIT2"="Units of coordinate increment and value",
"EXTNAME"="Image extension name")
data_keyvalues = list("XTENSION" = "IMAGE", "BITPIX"=-32, "NAXIS"=3,
"NAXIS1"=dim(simspin_cube)[1], "NAXIS2"=dim(simspin_cube)[2],
"NAXIS3"=dim(simspin_cube)[3], "PCOUNT"=0, "GCOUNT"=1,
"EXTNAME"="DATA", "HDUCLASS"="ESO",
"HDUDOC"="DICD", "HDUVERS"="DCID version 6",
"HDUCLAS1"="IMAGE", "HDUCLAS2"="DATA", "ERRDATA"="STAT",
"OBJECT"=object_name, "BUNIT"="erg/s/cm**2",
"CRPIX1"=1, "CRPIX2"=1,
"CDELT1"=-observation$sbin_size/observation$ang_size/3600,
"CDELT2"=observation$sbin_size/observation$ang_size/3600,
"CUNIT1"="deg", "CUNIT2"="deg",
"CTYPE1"="RA---TAN", "CTYPE2"="DEC--TAN",
"CSYER1"=character(1), "CSYER2"=character(1),
"CRVAL1"=(diff(observation$sbin_seq[1:2])/2 + observation$sbin_seq[1])/observation$ang_size/3600,
"CRVAL2"=(diff(observation$sbin_seq[1:2])/2 + observation$sbin_seq[1])/observation$ang_size/3600,
"CTYPE3"=character(1), "CUNIT3"=character(1),
"CDELT3"=numeric(1), "CRPIX3"=1,
"CRVAL3"=numeric(1))
data_keycomments = list("XTENSION"="IMAGE extension",
"BITPIX"="number of bits per data pixel",
"NAXIS"="number of data axes",
"NAXIS1"="axis length", "NAXIS2"="axis length",
"NAXIS3"="axis length",
"PCOUNT"="required keyword; must = 0",
"GCOUNT"="required keyword; must = 1",
"EXTNAME"="This extension contains data values",
"HDUCLASS"="class name (ESO format)",
"HDUDOC"="document with class description",
"HDUVERS"="version number (according to spec v2.5.1)",
"HDUCLAS1"="Image data format",
"HDUCLAS2"="this extension contains the data itself",
"ERRDATA"="pointer to the variance extension",
"OBJECT"="simulation and galaxy ID number",
"BUNIT"="Angstrom",
"CRPIX1"="Pixel coordinate of reference point",
"CRPIX2"="Pixel coordinate of reference point",
"CDELT1"="Coordinate transformation matrix element",
"CDELT2"="Coordinate transformation matrix element",
"CUNIT1"="Units of coordinate increment and value",
"CUNIT2"="Units of coordinate increment and value",
"CTYPE1"="Right ascension, gnomonic projection",
"CTYPE2"="Declination, gnomonic projection",
"CSYER1"="[deg] Systematic error in coordinate",
"CSYER2"="[deg] Systematic error in coordinate",
"CRVAL1"="Pixel value at reference point",
"CRVAL2"="Pixel value at reference point",
"CTYPE3"=character(1),
"CUNIT3"="Units of coordinate increment and value",
"CDELT3"="Coordinate transformation matrix element",
"CRPIX3"="Pixel coordinate of reference point",
"CRVAL3"="Pixel value at reference point")
library(testthat)
context("Testing build_datacube function.\n")
ss_pd_hdf5  = system.file("extdata", "SimSpin_example_HDF5.hdf5", package = "SimSpin")
ss_pd_eagle = system.file("extdata", "SimSpin_example_EAGLE.hdf5", package = "SimSpin")
ss_pd_magneticum = system.file("extdata", "SimSpin_example_Magneticum.hdf5", package = "SimSpin")
ss_gadget   = system.file("extdata", "SimSpin_example_Gadget_spectra.Rdata", package = "SimSpin")
ss_hdf5     = make_simspin_file(ss_pd_hdf5, write_to_file = FALSE)
ss_eagle    = make_simspin_file(ss_pd_eagle, write_to_file = FALSE)
ss_magneticum = make_simspin_file(ss_pd_magneticum, write_to_file = FALSE)
temp_loc = tempdir()
built_cube_size = 4
spectra_raw_images_size = 4
spectra_observed_images_size = NULL
velocity_raw_images_size = 6
velocity_observed_images_size = 3
expect_length(build_datacube(simspin_file = ss_gadget,
telescope = telescope(type="IFU", lsf_fwhm = 3.6, signal_to_noise = 3),
observing_strategy = observing_strategy(z = 0.05, inc_deg = 45, blur = T),
write_fits = T), built_cube_size)
expect_length(build_datacube(simspin_file = ss_gadget,
telescope = telescope(type="IFU", method="velocity", lsf_fwhm = 3.6, signal_to_noise = 3),
observing_strategy = observing_strategy(z = 0.05, inc_deg = 45, blur = T),
write_fits = T, output_location = paste0(temp_loc, "velocity_cube.FITS")), built_cube_size)
expect_length(build_datacube(simspin_file = ss_eagle,
telescope = telescope(type="IFU", method="gas", lsf_fwhm = 3.6, signal_to_noise = 3),
observing_strategy = observing_strategy(z = 0.05, inc_deg = 45, blur = T),
write_fits = T, output_location = paste0(temp_loc, "gas_velocity_cube.FITS")), built_cube_size)
expect_length(build_datacube(simspin_file = ss_magneticum,
telescope = telescope(type="IFU", method="sf gas", lsf_fwhm = 3.6, signal_to_noise = 3),
observing_strategy = observing_strategy(z = 0.05, inc_deg = 45, blur = T),
write_fits = T, output_location = paste0(temp_loc, "sfgas_velocity_cube.FITS")), built_cube_size)
expect_length(build_datacube(simspin_file = ss_hdf5,
telescope = telescope(type="IFU", lsf_fwhm = 3.6, signal_to_noise = 3),
observing_strategy = observing_strategy(z = 0.05, inc_deg = 45, blur = T),
write_fits = T, output_location = paste0(temp_loc, "cube.FITS")), built_cube_size)
library(SimSpin)
